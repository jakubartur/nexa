// Copyright (c) 2016-2021 The Bitcoin Unlimited Developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include "blockrelay/blockrelay_common.h"
#include "blockrelay/thinblock.h"
#include "bloom.h"
#include "chainparams.h"
#include "dosman.h"
#include "main.h"
#include "net.h"
#include "net_processing.h"
#include "primitives/block.h"
#include "protocol.h"
#include "random.h"
#include "requestManager.h"
#include "serialize.h"
#include "streams.h"
#include "txmempool.h"
#include "uint256.h"
#include "unlimited.h"
#include "util.h"
#include "utilstrencodings.h"
#include "validation/validation.h"
#include "version.h"

#include "test/test_nexa.h"

#include <atomic>
#include <boost/test/unit_test.hpp>
#include <sstream>
#include <string.h>

extern CTweak<uint64_t> maxAllowedNetMessage;
extern CTweak<unsigned int> blkRetryInterval;

/**
 * Generally this series of tests will do Message Consistency checking for p2p messages.  If the messages are not
 * formatted correctly then a ban will result.
 *
 * However we will also do other types of exploit testing, as much as is possible, through the unit test framework.
 */
BOOST_FIXTURE_TEST_SUITE(exploit_tests, TestingSetup)

// NOTE:  When creating test cases be sure to always set your nVersion and fSuccessfullyConneted flag as follows.
//
//    CNode dummyNode1(INVALID_SOCKET, addr1, "", true);
//    dummyNode1.nVersion = MIN_PEER_PROTO_VERSION;
//    dummyNode1.fSuccessfullyConnected = true;


CBlock block = TestBlock1();


// create dummy test addrs
CAddress addr1(ipaddress(0xa0b0c001, 10000));
CAddress addr2(ipaddress(0xa0b0c002, 10001));
CAddress addr3(ipaddress(0xa0b0c003, 10002));
CAddress addr4(ipaddress(0xa0b0c004, 10003));
CAddress addr5(ipaddress(0xa0b0c005, 10004));

// create recv queues
CDataStream vRecv1(SER_NETWORK, PROTOCOL_VERSION);
CDataStream vRecv2(SER_NETWORK, PROTOCOL_VERSION);
CDataStream vRecv3(SER_NETWORK, PROTOCOL_VERSION);
CDataStream vRecv4(SER_NETWORK, PROTOCOL_VERSION);
CDataStream vRecv5(SER_NETWORK, PROTOCOL_VERSION);

// create a basic nullhash
uint256 nullhash;

// create a general shared pointers for a thintype block
std::shared_ptr<CBlockThinRelay> pblock6 = std::make_shared<CBlockThinRelay>(CBlockThinRelay());
std::shared_ptr<CBlockThinRelay> pblock7 = std::make_shared<CBlockThinRelay>(CBlockThinRelay());
std::shared_ptr<CBlockThinRelay> pblock8 = std::make_shared<CBlockThinRelay>(CBlockThinRelay());
std::shared_ptr<CBlockThinRelay> pblock9 = std::make_shared<CBlockThinRelay>(CBlockThinRelay());

BOOST_AUTO_TEST_CASE(version_tests)
{
    int64_t nTime = GetTime();
    CAddress addrMe = GetLocalAddress(&addr1);
    uint64_t nServices = 1;

    // Recieve VERSION with no prior VERSION received yet.  Should not ban
    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode1(INVALID_SOCKET, addr1, "", true);
    dummyNode1.nVersion = 0;
    int nVersion = MIN_PEER_PROTO_VERSION;
    vRecv1 << nVersion << nServices << nTime << addrMe;
    ProcessMessage(&dummyNode1, NetMsgType::VERSION, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1);
    BOOST_CHECK(dummyNode1.nVersion);
    BOOST_CHECK(!dosMan.IsBanned(addr1));

    // Receive VERSION with no prior VERSION received but invalid protocol version, which should result in ban
    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode1a(INVALID_SOCKET, addr1, "", true);
    dummyNode1a.nVersion = 0;
    nVersion = MIN_PEER_PROTO_VERSION - 1;
    vRecv1 << nVersion << nServices << nTime << addrMe;
    ProcessMessage(&dummyNode1a, NetMsgType::VERSION, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1a);
    BOOST_CHECK(dummyNode1a.nVersion);
    BOOST_CHECK(dosMan.IsBanned(addr1));

    // Receive duplicate VERSION, nVersion will not be zero and should result in a disconnect
    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode2(INVALID_SOCKET, addr2, "", true);
    dummyNode2.nVersion = MIN_PEER_PROTO_VERSION;
    vRecv1 << nVersion << nServices << nTime << addrMe;
    ProcessMessage(&dummyNode2, NetMsgType::VERSION, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode2);
    BOOST_CHECK(dummyNode2.nVersion);
    BOOST_CHECK(dummyNode2.fDisconnect);

// Receive any message without receiving the version message first - this should cause a disconnect
#if 0 // with parallel message processing this is possible so should not cause a disconnect
    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode3(INVALID_SOCKET, addr3, "", true);
    dummyNode3.nVersion = 0;
    ProcessMessage(&dummyNode3, NetMsgType::PING, vRecv1,  GetStopwatchMicros());
    SendMessages(&dummyNode3);
    BOOST_CHECK(!dummyNode3.nVersion);
    BOOST_CHECK(dummyNode3.fDisconnect);
#endif
}

BOOST_AUTO_TEST_CASE(verack_tests)
{
    // Receive VERACK after VERSION sent
    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode1(INVALID_SOCKET, addr1, "", true);
    dummyNode1.nVersion = MIN_PEER_PROTO_VERSION;
    dummyNode1.tVersionSent = GetTime(); // should not cause ban if VERSION was sent
    ProcessMessage(&dummyNode1, NetMsgType::VERACK, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1);
    BOOST_CHECK(dummyNode1.tVersionSent >= 0);
    BOOST_CHECK(dummyNode1.fSuccessfullyConnected);
    BOOST_CHECK(!dosMan.IsBanned(addr1));

    // Receive VERACK but no VERSION sent
    dummyNode1.tVersionSent = -1; // should cause disconnect
    ProcessMessage(&dummyNode1, NetMsgType::VERACK, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1);
    BOOST_CHECK(dummyNode1.tVersionSent < 0);
    BOOST_CHECK(dummyNode1.fDisconnect);

    // Receive duplicate VERACK after VERSION sent. fSuccessfullyConnected will already be true.
    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode2(INVALID_SOCKET, addr2, "", true);
    dummyNode2.nVersion = MIN_PEER_PROTO_VERSION;
    dummyNode2.tVersionSent = GetTime();
    ProcessMessage(&dummyNode2, NetMsgType::VERACK, vRecv1, GetStopwatchMicros());
    ProcessMessage(&dummyNode2, NetMsgType::VERACK, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode2);
    BOOST_CHECK(dummyNode2.fSuccessfullyConnected);
    BOOST_CHECK(dummyNode2.fDisconnect);

    // Test the disconnect of a peer if the VERACK_TIMEOUT is exceeded
    int64_t nStartTime = GetTime();

    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode3(INVALID_SOCKET, addr3, "", true);
    // should cause disconnect if VERSION was already sent
    dummyNode3.nVersion = MIN_PEER_PROTO_VERSION;
    dummyNode3.tVersionSent = nStartTime;
    dummyNode3.fSuccessfullyConnected = false;
    dummyNode3.fDisconnect = false;
    SetMockTime(nStartTime + VERACK_TIMEOUT + 1);
    ProcessMessage(&dummyNode3, NetMsgType::VERACK, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode3);
    BOOST_CHECK(dummyNode3.tVersionSent >= 0);
    BOOST_CHECK(!dosMan.IsBanned(addr3));
    // not successfully connected and disconnected
    BOOST_CHECK(!dummyNode3.fSuccessfullyConnected);
    BOOST_CHECK(dummyNode3.fDisconnect);

    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode4(INVALID_SOCKET, addr4, "", true);
    dummyNode4.nVersion = 1;
    dummyNode4.tVersionSent = nStartTime;
    SetMockTime(nStartTime + VERACK_TIMEOUT); // should not disconnect if timeout not exceeded and no VERACK
    vRecv1 << (uint64_t)12345; // ping nonce
    {
        READLOCK(dummyNode4.csMsgSerializer);
        ProcessMessage(&dummyNode4, NetMsgType::PING, vRecv1, GetStopwatchMicros());
    }
    BOOST_CHECK(!dummyNode4.fDisconnect);

    vRecv1.clear();
    dosMan.ClearBanned();
    CNode dummyNode4a(INVALID_SOCKET, addr4, "", true);
    dummyNode4a.nVersion = 1;
    dummyNode4a.tVersionSent = nStartTime;
    dummyNode4a.fSuccessfullyConnected = false;
    SetMockTime(nStartTime + VERACK_TIMEOUT + 1); // should disconnect if timeout exceeded and no VERACK
    vRecv1 << (uint64_t)12345; // ping nonce
    {
        READLOCK(dummyNode4.csMsgSerializer);
        ProcessMessage(&dummyNode4a, NetMsgType::PING, vRecv1, GetStopwatchMicros());
    }
    BOOST_CHECK(dummyNode4a.fDisconnect);
}

BOOST_AUTO_TEST_CASE(inv_tests)
{
    // send more INV than the limit of MAX_INV_SZ
    vRecv1.clear();
    dosMan.ClearBanned();
    std::vector<CInv> vInv;

    CInv testINV(MSG_TX, TestBlock1().GetHash());
    for (unsigned int i = 0; i < MAX_INV_SZ; i++)
        vInv.push_back(testINV);

    CNode dummyNode1(INVALID_SOCKET, addr1, "", true);
    SetConnected(dummyNode1);
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());

    SendMessages(&dummyNode1); // sending five messages below MAX_INV_SZ should not cause ban
    BOOST_CHECK(vInv.size() <= MAX_INV_SZ);
    BOOST_CHECK(!dosMan.IsBanned(addr1));

    vInv.push_back(testINV); // Add one more INV which should cause a ban

    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1); // send four messages should not cause ban
    BOOST_CHECK(vInv.size() > MAX_INV_SZ);
    BOOST_CHECK(!dosMan.IsBanned(addr1));

    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1); // sending a fifth message is on the cusp of banning, based on elapsed time
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode1, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode1); // send a sixth message will cause a ban
    BOOST_CHECK(vInv.size() > MAX_INV_SZ);
    BOOST_CHECK(dosMan.IsBanned(addr1));


    // Create INV's with unknown types at the boundaries of what is valid, and
    // check that they are flagged as such
    CInv invalidINV(8, TestBlock1().GetHash());
    CInv invalidINV2(0, TestBlock1().GetHash());
    BOOST_CHECK(!invalidINV.IsKnownType());
    BOOST_CHECK(!invalidINV2.IsKnownType());

    // Create INV's with known types and make sure they work
    CInv validINV_1(1, TestBlock1().GetHash());
    CInv validINV_2(2, TestBlock1().GetHash());
    CInv validINV_3(3, TestBlock1().GetHash());
    CInv validINV_4(4, TestBlock1().GetHash());
    CInv validINV_5(5, TestBlock1().GetHash());
    CInv validINV_6(6, TestBlock1().GetHash());
    CInv validINV_7(7, TestBlock1().GetHash());
    BOOST_CHECK(validINV_1.IsKnownType());
    BOOST_CHECK(validINV_2.IsKnownType());
    BOOST_CHECK(validINV_3.IsKnownType());
    BOOST_CHECK(validINV_4.IsKnownType());
    BOOST_CHECK(validINV_5.IsKnownType());
    BOOST_CHECK(validINV_6.IsKnownType());
    BOOST_CHECK(validINV_7.IsKnownType());


    // INV with invalid type
    vRecv1.clear();
    vInv.clear();
    dosMan.ClearBanned();

    CInv txINV(MSG_TX, TestBlock1().GetHash());
    CInv blockINV(MSG_BLOCK, TestBlock1().GetHash());
    for (unsigned int i = 0; i < 10; i++)
    {
        vInv.push_back(txINV);
        vInv.push_back(blockINV);
    }
    vInv.push_back(invalidINV); // add one invalid

    CNode dummyNode3(INVALID_SOCKET, addr3, "", true);
    SetConnected(dummyNode3);
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode3, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode3, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode3, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode3, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode3); // send four messages should not cause ban
    BOOST_CHECK(!dosMan.IsBanned(addr3));

    vRecv1 << vInv;
    ProcessMessage(&dummyNode3, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode3); // send a fifth message and should not cause ban
    BOOST_CHECK(!dosMan.IsBanned(addr3));


    // INV with null hash
    vRecv1.clear();
    vInv.clear();
    nullhash.SetNull();
    dosMan.ClearBanned();

    CInv nullINV(MSG_BLOCK, nullhash);
    for (unsigned int i = 0; i < 10; i++)
    {
        vInv.push_back(txINV);
        vInv.push_back(blockINV);
    }
    vInv.push_back(nullINV); // add one with null hash

    CNode dummyNode5(INVALID_SOCKET, addr5, "", true);
    SetConnected(dummyNode5);
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode5, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode5, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode5, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode5, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode5); // send four messages should not cause ban
    BOOST_CHECK(!dosMan.IsBanned(addr5));

    vRecv1.clear();
    vRecv1 << vInv;
    ProcessMessage(&dummyNode5, NetMsgType::INV, vRecv1, GetStopwatchMicros());
    SendMessages(&dummyNode5); // send a fifth message should not cause ban
    BOOST_CHECK(!dosMan.IsBanned(addr5));
}

BOOST_AUTO_TEST_CASE(transaction_tests)
{
    // Transaction tests are handled in transaction_tests.cpp and fully covered there.
}

BOOST_AUTO_TEST_CASE(block_tests)
{
    // Block tests are handled in checkblock_tests.cpp and fully covered there.
}

BOOST_AUTO_TEST_CASE(compactblock_tests)
{
    fImporting = false;
    fReindex = false;
    bool fInit = false;
    IsInitialBlockDownloadInit(&fInit);
    dosMan.ClearBanned();

    /** CompactBlock message consistency checks */
    // Those tests are found in compactblock_tests.cpp

    /** CompactReReq consistency checks */

    // test empty indexes
    {
        CompactReRequest req1;
        req1.blockhash = InsecureRand256();
        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);
        stream << req1;
        vRecv1.clear();
        vRecv1 << stream;
        std::unique_ptr<CNode> dummyNodeCompact(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNode = *dummyNodeCompact;
        dummyNode.fSupportsCompactBlocks = true;
        SetConnected(dummyNode);
        ProcessMessage(&dummyNode, NetMsgType::GETBLOCKTXN, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode);
        BOOST_CHECK(dosMan.IsBanned(addr1));
        dosMan.ClearBanned();
    }

    // test null hash
    {
        CompactReRequest req1;
        req1.blockhash.SetNull();
        req1.indexes.resize(4);
        req1.indexes[0] = 0;
        req1.indexes[1] = 1;
        req1.indexes[2] = 3;
        req1.indexes[3] = 4;

        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);
        stream << req1;
        vRecv1.clear();
        vRecv1 << stream;
        std::unique_ptr<CNode> dummyNodeCompact(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNode = *dummyNodeCompact;
        dummyNode.fSupportsCompactBlocks = true;
        SetConnected(dummyNode);
        ProcessMessage(&dummyNode, NetMsgType::GETBLOCKTXN, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode);
        BOOST_CHECK(dosMan.IsBanned(addr1));
        dosMan.ClearBanned();
    }

    /** CompactReReqResponse consistency checks */

    // test null hash
    {
        CompactReReqResponse response1;
        response1.blockhash.SetNull();
        response1.txn.resize(1);
        response1.txn[0] = *TestBlock1().vtx[1];

        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);
        stream << response1;
        vRecv1.clear();
        vRecv1 << stream;
        std::unique_ptr<CNode> dummyNodeCompact(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNode = *dummyNodeCompact;
        dummyNode.fSupportsCompactBlocks = true;
        SetConnected(dummyNode);
        auto pblock = thinrelay.SetBlockToReconstruct(&dummyNode, TestBlock1().GetHash());
        ProcessMessage(&dummyNode, NetMsgType::BLOCKTXN, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode);
        BOOST_CHECK(dosMan.IsBanned(addr1));
        dosMan.ClearBanned();
    }

    // txn empty
    {
        CompactReReqResponse response2;
        response2.blockhash = TestBlock1().GetHash();

        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);
        stream << response2;
        vRecv1.clear();
        vRecv1 << stream;
        std::unique_ptr<CNode> dummyNodeCompact(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNode = *dummyNodeCompact;
        dummyNode.fSupportsCompactBlocks = true;
        SetConnected(dummyNode);
        auto pblock = thinrelay.SetBlockToReconstruct(&dummyNode, TestBlock1().GetHash());
        ProcessMessage(&dummyNode, NetMsgType::BLOCKTXN, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode);
        BOOST_CHECK(dosMan.IsBanned(addr1));
        dosMan.ClearBanned();
    }
}

BOOST_AUTO_TEST_CASE(thinblock_tests)
{
    fImporting = false;
    fReindex = false;
    bool fInit = false;
    IsInitialBlockDownloadInit(&fInit);
    dosMan.ClearBanned();
    const Consensus::Params &consensusParams = Params().GetConsensus();
    CBloomFilter filter;
    std::vector<uint256> vOrphanHashes;
    // Create 10 random hashes to seed the orphanhash vector.  This way we will create a bloom filter
    // with a size of 10 elements.
    std::string hash = "3fba505b48865fccda4e248cecc39d5dfbc6b8ef7b4adc9cd27242c1193c714";
    for (int i = 0; i < 10; i++)
    {
        std::stringstream ss;
        ss << i;
        hash.append(ss.str());
        uint256 random_hash = uint256S(hash);
        vOrphanHashes.push_back(random_hash);
    }
    std::unique_ptr<CNode> dummyNodeMem(new CNode(INVALID_SOCKET, addr1, "", true));
    CNode &dummyNode = *dummyNodeMem;
    BuildSeededBloomFilter(filter, vOrphanHashes, TestBlock1().GetHash(), &dummyNode, true);

    block = TestBlock1();
    CThinBlock thinblock(block, filter);
    CXThinBlock xthinblock(block, &filter);

    /** FILTERSIZEXTHIN tests */

    CDataStream ssSend(SER_NETWORK, INIT_PROTO_VERSION);
    ssSend << (uint32_t)36000;

    dosMan.ClearBanned();
    vRecv1.clear();
    vRecv1 << ssSend;
    {
        std::unique_ptr<CNode> dummyNodeAMem(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNodeA = *dummyNodeMem;
        dummyNodeA.nServices |= NODE_XTHIN;
        SetConnected(dummyNodeA);
        ProcessMessage(&dummyNodeA, NetMsgType::FILTERSIZEXTHIN, vRecv1, GetStopwatchMicros());
        BOOST_CHECK(!dummyNodeA.fDisconnect); // node should not be disconnected
    }

    dosMan.ClearBanned();
    vRecv1.clear();
    vRecv1 << ssSend;

    {
        std::unique_ptr<CNode> dummyNodeBMem(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNodeB = *dummyNodeBMem;
        dummyNodeB.nServices |= NODE_BLOOM;
        SetConnected(dummyNodeB);
        ProcessMessage(&dummyNodeB, NetMsgType::FILTERSIZEXTHIN, vRecv1, GetStopwatchMicros());
        BOOST_CHECK(dummyNodeB.fDisconnect); // node should be disconnected
    }

    dosMan.ClearBanned();
    vRecv1.clear();
    vRecv1 << ssSend;

    {
        std::unique_ptr<CNode> dummyNodeCMem(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNodeC = *dummyNodeCMem;
        dummyNodeC.nServices |= NODE_XTHIN;
        dummyNodeC.nServices |= NODE_BLOOM;
        SetConnected(dummyNodeC);
        ProcessMessage(&dummyNodeC, NetMsgType::FILTERSIZEXTHIN, vRecv1, GetStopwatchMicros());
        BOOST_CHECK(!dummyNodeC.fDisconnect); // node should not be disconnected
    }

    // Send a filter message indicating a size that is less than the default 36000.
    // This should get a disconnect.
    CDataStream ssSend2(SER_NETWORK, INIT_PROTO_VERSION);
    ssSend2 << (uint32_t)35999;

    dosMan.ClearBanned();
    vRecv1.clear();
    vRecv1 << ssSend2;

    {
        std::unique_ptr<CNode> dummyNodeDMem(new CNode(INVALID_SOCKET, addr1, "", true));
        CNode &dummyNodeD = *dummyNodeDMem;
        dummyNodeD.nServices |= NODE_XTHIN;
        SetConnected(dummyNodeD);
        ProcessMessage(&dummyNodeD, NetMsgType::FILTERSIZEXTHIN, vRecv1, GetStopwatchMicros());
        BOOST_CHECK(dummyNodeD.fDisconnect); // node should be disconnected
    }

    /** XTHINBLOCK message consistency checks */

    // testing empty missingtx vector
    dosMan.ClearBanned();
    CXThinBlock xthin = xthinblock;
    xthin.vMissingTx.clear(); // empty the missingtx vector. This should cause an error.
    vRecv1.clear();
    vRecv1 << xthin;

    {
        CNode dummyNode1(INVALID_SOCKET, addr1, "", true);
        dummyNode1.nServices |= NODE_XTHIN;
        dummyNode1.nServices |= NODE_BLOOM;
        SetConnected(dummyNode1);
        ProcessMessage(&dummyNode1, NetMsgType::XTHINBLOCK, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode1);
        BOOST_CHECK(xthin.vMissingTx.size() == 0);
        BOOST_CHECK(dosMan.IsBanned(addr1));
    }

    // test invalid or missing coinbase
    dosMan.ClearBanned();
    vRecv1.clear();
    xthin = xthinblock;
    xthin.vMissingTx[0] = xthin.vMissingTx[1]; // delete the coinbase. This should cause an error.
    vRecv1 << xthin;

    {
        CNode dummyNode1a(INVALID_SOCKET, addr1, "", true);
        dummyNode1a.nServices |= NODE_XTHIN;
        dummyNode1a.nServices |= NODE_BLOOM;
        SetConnected(dummyNode1a);
        ProcessMessage(&dummyNode1a, NetMsgType::XTHINBLOCK, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode1a);
        BOOST_CHECK(!xthin.vMissingTx[0].IsCoinBase());
        BOOST_CHECK(dosMan.IsBanned(addr1));
    }

    // test invalid block header
    dosMan.ClearBanned();
    vRecv1.clear();
    xthin = xthinblock;
    xthin.header.nBits = 1; // create invalid block header
    vRecv1 << xthin;

    CValidationState state;

    {
        CNode dummyNode1b(INVALID_SOCKET, addr1, "", true);
        dummyNode1b.nServices |= NODE_XTHIN;
        dummyNode1b.nServices |= NODE_BLOOM;
        SetConnected(dummyNode1b);
        ProcessMessage(&dummyNode1b, NetMsgType::XTHINBLOCK, vRecv1, GetStopwatchMicros());
        SendMessages(&dummyNode1b);
        BOOST_CHECK(!CheckBlockHeader(consensusParams, xthin.header, state, true));
        BOOST_CHECK(dosMan.IsBanned(addr1));
    }
    /** THINBLOCK message consistency  checks */

    // test empty missingtx vector
    dosMan.ClearBanned();
    CThinBlock thin = thinblock;
    thin.vMissingTx.clear(); // empty the missingtx vector. This should cause an error.
    vRecv2 << thin;

    {
        CNode dummyNode2(INVALID_SOCKET, addr2, "", true);
        dummyNode2.nServices |= NODE_XTHIN;
        dummyNode2.nServices |= NODE_BLOOM;
        SetConnected(dummyNode2);
        ProcessMessage(&dummyNode2, NetMsgType::THINBLOCK, vRecv2, GetStopwatchMicros());
        SendMessages(&dummyNode2);
        BOOST_CHECK(thin.vMissingTx.size() == 0);
        BOOST_CHECK(dosMan.IsBanned(addr2));
    }

    // test invalid or missing coinbase
    dosMan.ClearBanned();
    vRecv2.clear();
    thin = thinblock;
    thin.vMissingTx[0] = thin.vMissingTx[1]; // delete the coinbase. This should cause an error.
    vRecv2 << thin;

    {
        CNode dummyNode2a(INVALID_SOCKET, addr2, "", true);
        dummyNode2a.nServices |= NODE_XTHIN;
        dummyNode2a.nServices |= NODE_BLOOM;
        SetConnected(dummyNode2a);
        ProcessMessage(&dummyNode2a, NetMsgType::THINBLOCK, vRecv2, GetStopwatchMicros());
        SendMessages(&dummyNode2a);
        BOOST_CHECK(!thin.vMissingTx[0].IsCoinBase());
        BOOST_CHECK(dosMan.IsBanned(addr2));
    }

    // create invalid block header
    dosMan.ClearBanned();
    vRecv2.clear();
    thin = thinblock;
    thin.header.nBits = 1;
    vRecv2 << thin;

    {
        CNode dummyNode2b(INVALID_SOCKET, addr2, "", true);
        dummyNode2b.nServices |= NODE_XTHIN;
        dummyNode2b.nServices |= NODE_BLOOM;
        SetConnected(dummyNode2b);
        ProcessMessage(&dummyNode2b, NetMsgType::THINBLOCK, vRecv2, GetStopwatchMicros());
        SendMessages(&dummyNode2b);
        BOOST_CHECK(!CheckBlockHeader(consensusParams, thin.header, state, true));
        BOOST_CHECK(dosMan.IsBanned(addr2));
    }


    /** XBLOCKTX message consistency checks */

    // test null hash
    CBlock block3 = TestBlock1();

    dosMan.ClearBanned();
    nullhash.SetNull();
    std::vector<CTransaction> vtx;
    for (auto &tx : block3.vtx)
        vtx.push_back(*tx);

    CXThinBlockTx xblocktx(nullhash, vtx);
    vRecv3 << xblocktx;

    {
        CNode dummyNode3(INVALID_SOCKET, addr3, "", true);
        dummyNode3.nServices |= NODE_XTHIN;
        dummyNode3.nServices |= NODE_BLOOM;
        SetConnected(dummyNode3);
        auto pblock = thinrelay.SetBlockToReconstruct(&dummyNode3, nullhash);
        ProcessMessage(&dummyNode3, NetMsgType::XBLOCKTX, vRecv3, GetStopwatchMicros());
        SendMessages(&dummyNode3);
        BOOST_CHECK(nullhash.IsNull());
        BOOST_CHECK(dosMan.IsBanned(addr3));
    }

    // no block to reconstruct available
    {
        CNode dummyNode3(INVALID_SOCKET, addr3, "", true);
        std::shared_ptr<CBlockThinRelay> pblock = thinrelay.GetBlockToReconstruct(&dummyNode3, nullhash);
        BOOST_CHECK(pblock == nullptr);
    }

    // test no txns in xblocktx
    dosMan.ClearBanned();
    vRecv3.clear();
    std::vector<CTransaction> vTxEmpty;
    CXThinBlockTx xblocktx2(block3.GetHash(), vTxEmpty);
    vRecv3 << xblocktx2;

    {
        CNode dummyNode3a(INVALID_SOCKET, addr3, "", true);
        dummyNode3a.nServices |= NODE_XTHIN;
        dummyNode3a.nServices |= NODE_BLOOM;
        SetConnected(dummyNode3a);
        auto pblock = thinrelay.SetBlockToReconstruct(&dummyNode3a, block3.GetHash());
        ProcessMessage(&dummyNode3a, NetMsgType::XBLOCKTX, vRecv3, GetStopwatchMicros());
        SendMessages(&dummyNode3a);
        BOOST_CHECK(vTxEmpty.size() == 0);
        BOOST_CHECK(dosMan.IsBanned(addr3));
    }

    /** GET_XBLOCKTX message consistency checks */

    // test null hash
    dosMan.ClearBanned();
    nullhash.SetNull();
    std::set<uint64_t> setHashesToRequest;
    setHashesToRequest.insert(1); // add a hash so that we are not empty
    CXRequestThinBlockTx get_xblocktx(nullhash, setHashesToRequest);
    vRecv4 << get_xblocktx;

    {
        CNode dummyNode4(INVALID_SOCKET, addr4, "", true);
        dummyNode4.nServices |= NODE_XTHIN;
        dummyNode4.nServices |= NODE_BLOOM;
        SetConnected(dummyNode4);
        ProcessMessage(&dummyNode4, NetMsgType::GET_XBLOCKTX, vRecv4, GetStopwatchMicros());
        SendMessages(&dummyNode4);
        BOOST_CHECK(nullhash.IsNull());
        BOOST_CHECK(dosMan.IsBanned(addr4));
    }

    // test empty setHashesToRequest
    dosMan.ClearBanned();
    vRecv4.clear();
    setHashesToRequest.clear(); // clear the set
    CXRequestThinBlockTx get_xblocktx2(block3.GetHash(), setHashesToRequest);
    vRecv4 << get_xblocktx2;

    {
        std::unique_ptr<CNode> dummyNode4aMem(new CNode(INVALID_SOCKET, addr4, "", true));
        CNode &dummyNode4a = *dummyNode4aMem;
        dummyNode4a.nServices |= NODE_XTHIN;
        dummyNode4a.nServices |= NODE_BLOOM;
        SetConnected(dummyNode4a);
        ProcessMessage(&dummyNode4a, NetMsgType::GET_XBLOCKTX, vRecv4, GetStopwatchMicros());
        SendMessages(&dummyNode4a);
        BOOST_CHECK(setHashesToRequest.empty());
        BOOST_CHECK(dosMan.IsBanned(addr4));


        /** GET_XTHIN message consistency checks */

        // test get_xthin with null hash
        dosMan.ClearBanned();
        nullhash.SetNull();
        CInv inv(MSG_XTHINBLOCK, nullhash);
        CBloomFilter filterMemPool;
        BuildSeededBloomFilter(filterMemPool, vOrphanHashes, inv.hash, &dummyNode4a, true);
        vRecv5 << inv;
        vRecv5 << filterMemPool;

        std::unique_ptr<CNode> dummyNode5Mem(new CNode(INVALID_SOCKET, addr5, "", true));
        CNode &dummyNode5 = *dummyNode5Mem;
        dummyNode5.nServices |= NODE_XTHIN;
        dummyNode5.nServices |= NODE_BLOOM;
        SetConnected(dummyNode5);
        ProcessMessage(&dummyNode5, NetMsgType::GET_XTHIN, vRecv5, GetStopwatchMicros());
        SendMessages(&dummyNode5);
        BOOST_CHECK(nullhash.IsNull());
        BOOST_CHECK(dosMan.IsBanned(addr5));

        // test get_xthin with invalid message type
        dosMan.ClearBanned();
        vRecv5.clear();
        CInv inv2(15, block3.GetHash()); // invalid type
        CBloomFilter filterMemPool2;
        BuildSeededBloomFilter(filterMemPool2, vOrphanHashes, inv2.hash, &dummyNode5, true);
        vRecv5 << inv2;
        vRecv5 << filterMemPool2;

        std::unique_ptr<CNode> dummyNode5aMem(new CNode(INVALID_SOCKET, addr5, "", true));
        CNode &dummyNode5a = *dummyNode5aMem;
        dummyNode5a.nServices |= NODE_XTHIN;
        dummyNode5a.nServices |= NODE_BLOOM;
        SetConnected(dummyNode5a);
        ProcessMessage(&dummyNode5a, NetMsgType::GET_XTHIN, vRecv5, GetStopwatchMicros());
        SendMessages(&dummyNode5a);
        BOOST_CHECK(inv2.type != MSG_THINBLOCK && inv2.type != MSG_XTHINBLOCK);
        BOOST_CHECK(dosMan.IsBanned(addr5));
    }


    /* Thinblock memory exhaustion attack 1 */

    // Get size of xthin and thinblock to be used later
    CXThinBlock xthinsize = xthinblock;
    vRecv1.clear();
    vRecv1 << xthinsize;
    vRecv1.clear();
    CThinBlock thinsize = thinblock;
    vRecv1 << thinsize;
    vRecv1.clear();

    // test a single valid thinblock reconstruction that goes over the limit.
    // result: the peer should have it data cleared and node should be disconnected.
    CNode dummyNode6(INVALID_SOCKET, addr1, "", true);
    {
        dosMan.ClearBanned();
        CXThinBlock xthin2 = xthinblock;
        CXThinBlock xthin2a = xthinblock;
        CThinBlock thin2 = thinblock;

        // Add the node to vNodes and also we need a thinblockinflight entry
        thinrelay.AddBlockInFlight(&dummyNode6, TestBlock1().GetHash(), NetMsgType::XTHINBLOCK);
        vNodes.push_back(&dummyNode6);

        // Set the max netmessage size to be very small so we can easily exceed that
        // value and cause a disconnect in the following tests
        maxAllowedNetMessage.Set(88);

        // Process an xthinblock which causes a disconnect
        dummyNode6.fDisconnect = false;
        SetConnected(dummyNode6);
        pblock6->SetNull();
        pblock6 = thinrelay.SetBlockToReconstruct(&dummyNode6, xthin2.header.GetHash());
        pblock6->xthinblock = std::make_shared<CXThinBlock>(xthin2);
        pblock6->xthinblock->process(&dummyNode6, NetMsgType::XTHINBLOCK, pblock6);
        BOOST_CHECK(dummyNode6.fDisconnect); // node should be disconnected

        // clean up vNodes, mapthinblocksinflight and thinblock data
        vNodes.pop_back();
        thinrelay.ClearAllBlockData(&dummyNode6, pblock6->GetHash());

        // Add the node to vNodes and also we need a thinblockinflight entry
        thinrelay.AddBlockInFlight(&dummyNode6, TestBlock1().GetHash(), NetMsgType::XTHINBLOCK);
        vNodes.push_back(&dummyNode6);

        // Process a regular thinblock
        dummyNode6.fDisconnect = false;
        SetConnected(dummyNode6);
        pblock6 = thinrelay.SetBlockToReconstruct(&dummyNode6, xthin2.header.GetHash());
        pblock6->thinblock = std::make_shared<CThinBlock>(thin2);
        pblock6->thinblock->process(&dummyNode6, pblock6);
        BOOST_CHECK(dummyNode6.fDisconnect); // node should be disconnected

        // clean up vNodes, mapthinblocksinflight and thinblock data
        vNodes.pop_back();
        thinrelay.ClearAllBlockData(&dummyNode6, pblock6->GetHash());

        // TODO: it would be great to have a test with an excessiveBlockSize of one byte larger
        //       so we can prove that a disconnect wouldn't happen for the edge case however
        //       that causes us to sent a messae back out through an invalid socket which then
        //       results in a crash.  It took a great deal of debugging to find this out so hence
        //       the comment here to help someone avoid any pitalls, for any future efforts.

        maxAllowedNetMessage.Set(0);
    }

    /*
     * Test the disconnection of a peers with thinblocks in flight that has gone over the timeout limit
     */
    {
        int64_t nStartTime = GetTime();
        uint256 hash1 = uint256S("3fba505b48865fccda4e248cecc39d5dfbc6b8ef7b4adc9cd27242c1193c7141");
        uint256 hash2 = uint256S("3fba505b48865fccda4e248cecc39d5dfbc6b8ef7b4adc9cd27242c1193c7142");

        CNode dummyNode1(INVALID_SOCKET, addr1, "", true);
        dummyNode1.fDisconnect = false;
        SetConnected(dummyNode1);

        CNode dummyNode2(INVALID_SOCKET, addr2, "", true);
        dummyNode2.fDisconnect = false;
        SetConnected(dummyNode2);

        SetMockTime(nStartTime);
        thinrelay.AddBlockInFlight(&dummyNode1, hash1, NetMsgType::XTHINBLOCK);
        SetMockTime(nStartTime + 1);
        thinrelay.AddBlockInFlight(&dummyNode1, hash2, NetMsgType::XTHINBLOCK);
        SetMockTime(nStartTime + 1);
        thinrelay.AddBlockInFlight(&dummyNode2, hash1, NetMsgType::XTHINBLOCK);

        // Move clock forward to the boundary of the timeout interval
        // No nodes should be disconnected.
        SetMockTime(nStartTime + (6 * blkRetryInterval.Value() / 1000000));
        SendMessages(&dummyNode1);
        SendMessages(&dummyNode2);
        BOOST_CHECK(!dummyNode1.fDisconnect);
        BOOST_CHECK(!dummyNode2.fDisconnect);


        // Move clock forward to 1 second past the boundary of the timeout interval
        // DummyNode1 should be disconnected
        // DummyNode2 should still be connected because it was added one second later.
        SetMockTime(nStartTime + (6 * blkRetryInterval.Value() / 1000000) + 1);
        SendMessages(&dummyNode1);
        SendMessages(&dummyNode2);
        BOOST_CHECK(dummyNode1.fDisconnect);
        BOOST_CHECK(!dummyNode2.fDisconnect);

        // Move clock forward to 1 second past the boundary of the timeout interval
        // DummyNode2 should now be disconnected
        SetMockTime(nStartTime + (6 * blkRetryInterval.Value() / 1000000) + 2);
        SendMessages(&dummyNode2);
        BOOST_CHECK(dummyNode2.fDisconnect);
    }

    // cleanup received queues
    vRecv1.clear();
    vRecv2.clear();
    vRecv3.clear();
    vRecv4.clear();
    vRecv5.clear();
}
BOOST_AUTO_TEST_SUITE_END()
